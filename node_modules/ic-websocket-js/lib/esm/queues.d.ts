/**
 * The function that will be called when an item is processed.
 * If the function returns false, the processing will stop.
 */
type QueueItemCallback<T> = (message: T) => boolean | Promise<boolean>;
type QueueArgs<T> = {
    /**
     * See {@link QueueItemCallback}
     */
    itemCallback: QueueItemCallback<T>;
    /**
     * If true, the queue will not process any items, even when {@link BaseQueue.process} is called.
     * To enable processing, call {@link BaseQueue.enable} or {@link BaseQueue.enableAndProcess}.
     * @default false
     */
    isDisabled?: boolean;
};
export declare class BaseQueue<T> {
    private _queue;
    private _itemCallback;
    private _canProcess;
    private _isProcessing;
    constructor(args: QueueArgs<T>);
    enable(): void;
    disable(): void;
    add(item: T): void;
    addAndProcess(item: T): void;
    enableAndProcess(): void;
    process(): void;
    private _processNext;
}
type AckMessagesQueueArgs = {
    expirationMs: number;
    timeoutExpiredCallback: AckTimeoutExpiredCallback;
};
type AckMessage = {
    sequenceNumber: bigint;
    addedAt: number;
};
type AckTimeoutExpiredCallback = (notReceivedAck: AckMessage['sequenceNumber'][]) => void;
export declare class AckMessagesQueue {
    private _queue;
    private _expirationMs;
    private _timeoutExpiredCallback;
    private _lastAckTimeout;
    constructor(args: AckMessagesQueueArgs);
    private _startLastAckTimeout;
    private _restartLastAckTimeout;
    private _onTimeoutExpired;
    add(sequenceNumber: bigint): void;
    ack(sequenceNumber: bigint): void;
    last(): AckMessage | null;
    clear(): void;
}
export {};
