import { IDL } from "@dfinity/candid";
import { Actor } from '@dfinity/agent';
;
const ClientPrincipalIdl = IDL.Principal;
const GatewayPrincipalIdl = IDL.Principal;
const ClientKeyIdl = IDL.Record({
    'client_principal': ClientPrincipalIdl,
    'client_nonce': IDL.Nat64,
});
const WebsocketMessageIdl = IDL.Record({
    'sequence_num': IDL.Nat64,
    'content': IDL.Vec(IDL.Nat8),
    'client_key': ClientKeyIdl,
    'timestamp': IDL.Nat64,
    'is_service_message': IDL.Bool,
});
export const CanisterWsMessageArgumentsIdl = IDL.Record({ 'msg': WebsocketMessageIdl });
export const CanisterWsMessageResultIdl = IDL.Variant({
    'Ok': IDL.Null,
    'Err': IDL.Text,
});
const CanisterWsOpenArgumentsIdl = IDL.Record({
    'client_nonce': IDL.Nat64,
    'gateway_principal': GatewayPrincipalIdl,
});
const CanisterWsOpenResultIdl = IDL.Variant({
    'Ok': IDL.Null,
    'Err': IDL.Text,
});
export const wsOpenIdl = IDL.Func([CanisterWsOpenArgumentsIdl], [CanisterWsOpenResultIdl], []);
export const wsMessageIdl = IDL.Func([CanisterWsMessageArgumentsIdl, IDL.Opt(IDL.Null)], [CanisterWsMessageResultIdl], []);
const CanisterOpenMessageContentIdl = IDL.Record({
    'client_key': ClientKeyIdl,
});
const CanisterAckMessageContentIdl = IDL.Record({
    'last_incoming_sequence_num': IDL.Nat64,
});
const ClientKeepAliveMessageContentIdl = IDL.Record({
    'last_incoming_sequence_num': IDL.Nat64,
});
const CloseMessageReasonIdl = IDL.Variant({
    'WrongSequenceNumber': IDL.Null,
    'InvalidServiceMessage': IDL.Null,
    'KeepAliveTimeout': IDL.Null,
    'ClosedByApplication': IDL.Null,
});
const CanisterCloseMessageContentIdl = IDL.Record({
    'reason': CloseMessageReasonIdl,
});
const WebsocketServiceMessageContentIdl = IDL.Variant({
    'OpenMessage': CanisterOpenMessageContentIdl,
    'AckMessage': CanisterAckMessageContentIdl,
    'KeepAliveMessage': ClientKeepAliveMessageContentIdl,
    'CloseMessage': CanisterCloseMessageContentIdl,
});
export const decodeWebsocketServiceMessageContent = (bytes) => {
    const decoded = IDL.decode([WebsocketServiceMessageContentIdl], bytes);
    if (decoded.length !== 1) {
        throw new Error("Invalid CanisterServiceMessage");
    }
    return decoded[0];
};
export const encodeWebsocketServiceMessageContent = (msg) => {
    return new Uint8Array(IDL.encode([WebsocketServiceMessageContentIdl], [msg]));
};
export const isClientKeyEq = (a, b) => {
    return a.client_principal.compareTo(b.client_principal) === "eq" && a.client_nonce === b.client_nonce;
};
/**
 * Extracts the message type from the canister service definition.
 *
 * @throws {Error} if the canister does not implement the ws_message method
 * @throws {Error} if the application message type is not optional
 */
export const extractApplicationMessageIdlFromActor = (actor) => {
    const wsMessageMethod = Actor.interfaceOf(actor)._fields.find((f) => f[0] === "ws_message");
    if (!wsMessageMethod) {
        throw new Error("Canister does not implement ws_message method");
    }
    if (wsMessageMethod[1].argTypes.length !== 2) {
        throw new Error("ws_message method must have 2 arguments");
    }
    const applicationMessageArg = wsMessageMethod[1].argTypes[1];
    if (!(applicationMessageArg instanceof IDL.OptClass)) {
        throw new Error("Application message type must be optional in the ws_message arguments");
    }
    return applicationMessageArg["_type"]; // extract the underlying option type
};
//# sourceMappingURL=idl.js.map