{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":"AAAA,OAAO,EACL,IAAI,EACJ,WAAW,EACX,OAAO,EAGP,WAAW,EACX,oBAAoB,EACpB,WAAW,GACZ,MAAM,gBAAgB,CAAC;AAExB,OAAO,EAAE,MAAM,EAAE,MAAM,UAAU,CAAC;AAElC,MAAM,eAAe,GAAG,CAAC,IAAiB,EAAE,IAAiB,EAAW,EAAE;IACxE,OAAO,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;AACnC,CAAC,CAAA;AAED,MAAM,CAAC,MAAM,kBAAkB,GAAG,KAAK,EACrC,UAAqB,EACrB,IAAY,EACZ,IAA8B,EAC9B,WAAwB,EACxB,IAAiB,EACjB,KAAgB,EAChB,0BAAkC,EAChB,EAAE;IACpB,IAAI,IAAI,CAAC;IACT,IAAI,CAAC;QACH,IAAI,GAAG,MAAM,WAAW,CAAC,MAAM,CAAC;YAC9B,WAAW;YACX,UAAU;YACV,OAAO,EAAE,KAAK,CAAC,OAAQ;YACvB,eAAe,EAAE,0BAA0B;SAC5C,CAAC,CAAC;IACL,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,CAAC,KAAK,CAAC,6CAA6C,EAAE,KAAK,CAAC,CAAC;QACnE,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAW,IAAI,CAAC,CAAC;IAC7C,MAAM,aAAa,GAAG,MAAM,WAAW,CAAC,QAAQ,CAAC,CAAC;IAClD,MAAM,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC;QACtC,UAAU;QACV,UAAU,CAAC,YAAY,EAAE;QACzB,gBAAgB;KACjB,CAAC,CAAC;IACH,MAAM,OAAO,GAAG,oBAAoB,CAAC,mBAAmB,CAAC,CAAC;IAE1D,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,MAAM,IAAI,KAAK,CACb,qEAAqE,CACtE,CAAC;IACJ,CAAC;IAED,gEAAgE;IAChE,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,aAAa,CAAC,EAAE,CAAC;QAC7C,MAAM,CAAC,KAAK,CAAC,4DAA4D,CAAC,CAAC;QAC3E,OAAO,KAAK,CAAC;IACf,CAAC;IAED,0CAA0C;IAC1C,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACxD,IAAI,mBAAmB,GAAG,WAAW,CAAC,CAAC,WAAW,EAAE,IAAI,CAAC,EAAE,QAAQ,CAAC,CAAC;IACrE,IAAI,OAAO,GAAG,oBAAoB,CAAC,mBAAmB,CAAC,CAAC;IAExD,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,gCAAgC;QAChC,mBAAmB,GAAG,WAAW,CAAC,CAAC,WAAW,CAAC,EAAE,QAAQ,CAAC,CAAC;QAC3D,OAAO,GAAG,oBAAoB,CAAC,mBAAmB,CAAC,CAAC;IACtD,CAAC;IAED,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,wEAAwE;QACxE,oDAAoD;QACpD,MAAM,CAAC,KAAK,CACV,qEAAqE,IAAI,CAAC,SAAS,CACjF,IAAI,CACL,EAAE,CACJ,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO,CAAC,CAAC,OAAO,IAAI,eAAe,CAAC,GAAG,EAAE,OAAsB,CAAC,CAAC;AACnE,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,WAAW,GAAG,KAAK,EAC9B,EAAwB,EACxB,WAAmB,EACK,EAAE;IAC1B,IAAI,CAAC;QACH,OAAO,MAAM,OAAO,CAAC,OAAO,CAAC,EAAE,EAAE,CAAC,CAAC;IACrC,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;IAClC,CAAC;AACH,CAAC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,YAAY,GAAG,GAAW,EAAE;IACvC,gDAAgD;IAChD,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,CAAC,eAAe,EAAE,CAAC;QACpF,MAAM,KAAK,GAAG,IAAI,cAAc,CAAC,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QACrC,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;IACD,oFAAoF;IACpF,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,eAAe,EAAE,CAAC;QAC5D,MAAM,KAAK,GAAG,IAAI,cAAc,CAAC,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QAC9B,OAAO,KAAK,CAAC,CAAC,CAAC,CAAC;IAClB,CAAC;IACD,6CAA6C;IAC7C,aAAa;IACb,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,WAAW,EAAE,CAAC;QACxD,aAAa;QACb,MAAM,YAAY,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QAC3C,MAAM,eAAe,GAAG,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QACrD,OAAO,MAAM,CAAC,IAAI,GAAG,eAAe,CAAC,CAAC;IACxC,CAAC;IAED,mDAAmD;IACnD,MAAM,IAAI,KAAK,CAAC,4DAA4D,CAAC,CAAC;AAChF,CAAC,CAAC","sourcesContent":["import {\n  Cbor,\n  Certificate,\n  compare,\n  HashTree,\n  HttpAgent,\n  lookup_path,\n  lookupResultToBuffer,\n  reconstruct,\n} from \"@dfinity/agent\";\nimport { Principal } from \"@dfinity/principal\";\nimport { logger } from \"./logger\";\n\nconst areBuffersEqual = (buf1: ArrayBuffer, buf2: ArrayBuffer): boolean => {\n  return compare(buf1, buf2) === 0;\n}\n\nexport const isMessageBodyValid = async (\n  canisterId: Principal,\n  path: string,\n  body: Uint8Array | ArrayBuffer,\n  certificate: ArrayBuffer,\n  tree: ArrayBuffer,\n  agent: HttpAgent,\n  maxCertificateAgeInMinutes: number,\n): Promise<boolean> => {\n  let cert;\n  try {\n    cert = await Certificate.create({\n      certificate,\n      canisterId,\n      rootKey: agent.rootKey!,\n      maxAgeInMinutes: maxCertificateAgeInMinutes,\n    });\n  } catch (error) {\n    logger.error(\"[certification] Error creating certificate:\", error);\n    return false;\n  }\n\n  const hashTree = Cbor.decode<HashTree>(tree);\n  const reconstructed = await reconstruct(hashTree);\n  const witnessLookupResult = cert.lookup([\n    \"canister\",\n    canisterId.toUint8Array(),\n    \"certified_data\"\n  ]);\n  const witness = lookupResultToBuffer(witnessLookupResult);\n\n  if (!witness) {\n    throw new Error(\n      \"Could not find certified data for this canister in the certificate.\"\n    );\n  }\n\n  // First validate that the Tree is as good as the certification.\n  if (!areBuffersEqual(witness, reconstructed)) {\n    logger.error(\"[certification] Witness != Tree passed in ic-certification\");\n    return false;\n  }\n\n  // Next, calculate the SHA of the content.\n  const sha = await crypto.subtle.digest(\"SHA-256\", body);\n  let treeShaLookupResult = lookup_path([\"websocket\", path], hashTree);\n  let treeSha = lookupResultToBuffer(treeShaLookupResult);\n\n  if (!treeSha) {\n    // Allow fallback to index path.\n    treeShaLookupResult = lookup_path([\"websocket\"], hashTree);\n    treeSha = lookupResultToBuffer(treeShaLookupResult);\n  }\n\n  if (!treeSha) {\n    // The tree returned in the certification header is wrong. Return false.\n    // We don't throw here, just invalidate the request.\n    logger.error(\n      `[certification] Invalid Tree in the header. Does not contain path ${JSON.stringify(\n        path\n      )}`\n    );\n    return false;\n  }\n\n  return !!treeSha && areBuffersEqual(sha, treeSha as ArrayBuffer);\n};\n\nexport const safeExecute = async <T>(\n  fn: () => T | Promise<T>,\n  warnMessage: string\n): Promise<T | undefined> => {\n  try {\n    return await Promise.resolve(fn());\n  } catch (error) {\n    logger.warn(warnMessage, error);\n  }\n};\n\n/**\n * Generates a random unsigned 64-bit integer\n * @returns {bigint} a random bigint\n */\nexport const randomBigInt = (): bigint => {\n  // determine whether browser crypto is available\n  if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n    const array = new BigUint64Array(1);\n    window.crypto.getRandomValues(array);\n    return array[0];\n  }\n  // A second check for webcrypto, in case it is loaded under global instead of window\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    const array = new BigUint64Array(1);\n    crypto.getRandomValues(array);\n    return array[0];\n  }\n  // determine whether node crypto is available\n  // @ts-ignore\n  if (typeof crypto !== 'undefined' && crypto.randomBytes) {\n    // @ts-ignore\n    const randomBuffer = crypto.randomBytes(8);\n    const randomHexString = randomBuffer.toString('hex');\n    return BigInt('0x' + randomHexString);\n  }\n\n  // TODO: test these fallbacks in a node environment\n  throw new Error('Random UInt64 generation not supported in this environment');\n};\n"]}