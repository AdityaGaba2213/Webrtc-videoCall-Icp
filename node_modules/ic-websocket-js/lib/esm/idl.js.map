{"version":3,"file":"idl.js","sourceRoot":"","sources":["../../src/idl.ts"],"names":[],"mappings":"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","sourcesContent":["import { IDL } from \"@dfinity/candid\";\nimport type { Principal } from '@dfinity/principal';\nimport { Actor, ActorSubclass, type ActorMethod } from '@dfinity/agent';\nimport type { GetInnerType } from \"./types\";\n\ntype ClientPrincipal = Principal;\ntype GatewayPrincipal = Principal;\nexport type ClientKey = {\n  'client_principal': ClientPrincipal,\n  'client_nonce': bigint,\n}\nexport interface WebsocketMessage {\n  'sequence_num': bigint,\n  'content': Uint8Array | number[],\n  'client_key': ClientKey,\n  'timestamp': bigint,\n  'is_service_message': boolean,\n}\nexport interface CanisterWsMessageArguments { 'msg': WebsocketMessage }\nexport type CanisterWsMessageResult = { 'Ok': null } |\n{ 'Err': string };\nexport type CanisterWsOpenArguments = {\n  'client_nonce': bigint,\n  'gateway_principal': GatewayPrincipal,\n};\nexport type CanisterWsOpenResult = { 'Ok': null } |\n{ 'Err': string };\nexport interface _WS_CANISTER_SERVICE<T = any> {\n  'ws_message': ActorMethod<\n    [CanisterWsMessageArguments, [] | [T]],\n    CanisterWsMessageResult\n  >,\n  'ws_open': ActorMethod<[CanisterWsOpenArguments], CanisterWsOpenResult>,\n};\n\n/**\n * Extracts the application message type from the canister service definition.\n */\nexport type GetApplicationMessageType<Service extends _WS_CANISTER_SERVICE> = Exclude<GetInnerType<Service[\"ws_message\"]>[1], []>[0];\n\nconst ClientPrincipalIdl = IDL.Principal;\nconst GatewayPrincipalIdl = IDL.Principal;\nconst ClientKeyIdl = IDL.Record({\n  'client_principal': ClientPrincipalIdl,\n  'client_nonce': IDL.Nat64,\n});\n\nconst WebsocketMessageIdl = IDL.Record({\n  'sequence_num': IDL.Nat64,\n  'content': IDL.Vec(IDL.Nat8),\n  'client_key': ClientKeyIdl,\n  'timestamp': IDL.Nat64,\n  'is_service_message': IDL.Bool,\n});\nexport const CanisterWsMessageArgumentsIdl = IDL.Record({ 'msg': WebsocketMessageIdl });\nexport const CanisterWsMessageResultIdl = IDL.Variant({\n  'Ok': IDL.Null,\n  'Err': IDL.Text,\n});\nconst CanisterWsOpenArgumentsIdl = IDL.Record({\n  'client_nonce': IDL.Nat64,\n  'gateway_principal': GatewayPrincipalIdl,\n});\nconst CanisterWsOpenResultIdl = IDL.Variant({\n  'Ok': IDL.Null,\n  'Err': IDL.Text,\n});\n\nexport const wsOpenIdl = IDL.Func([CanisterWsOpenArgumentsIdl], [CanisterWsOpenResultIdl], []);\nexport const wsMessageIdl = IDL.Func([CanisterWsMessageArgumentsIdl, IDL.Opt(IDL.Null)], [CanisterWsMessageResultIdl], []);\n\ntype CanisterOpenMessageContent = {\n  'client_key': ClientKey,\n};\nexport type CanisterAckMessageContent = {\n  'last_incoming_sequence_num': bigint,\n};\nexport type ClientKeepAliveMessageContent = {\n  'last_incoming_sequence_num': bigint,\n};\nexport type CloseMessageReason = {\n  WrongSequenceNumber: null,\n} | {\n  InvalidServiceMessage: null,\n} | {\n  KeepAliveTimeout: null,\n} | {\n  ClosedByApplication: null\n};\nexport type CanisterCloseMessageContent = {\n  reason: CloseMessageReason,\n};\nexport type WebsocketServiceMessageContent = {\n  OpenMessage: CanisterOpenMessageContent,\n} | {\n  AckMessage: CanisterAckMessageContent,\n} | {\n  KeepAliveMessage: ClientKeepAliveMessageContent,\n} | {\n  CloseMessage: CanisterCloseMessageContent,\n};\n\nconst CanisterOpenMessageContentIdl = IDL.Record({\n  'client_key': ClientKeyIdl,\n});\nconst CanisterAckMessageContentIdl = IDL.Record({\n  'last_incoming_sequence_num': IDL.Nat64,\n});\nconst ClientKeepAliveMessageContentIdl = IDL.Record({\n  'last_incoming_sequence_num': IDL.Nat64,\n});\nconst CloseMessageReasonIdl = IDL.Variant({\n  'WrongSequenceNumber': IDL.Null,\n  'InvalidServiceMessage': IDL.Null,\n  'KeepAliveTimeout': IDL.Null,\n  'ClosedByApplication': IDL.Null,\n});\nconst CanisterCloseMessageContentIdl = IDL.Record({\n  'reason': CloseMessageReasonIdl,\n})\nconst WebsocketServiceMessageContentIdl = IDL.Variant({\n  'OpenMessage': CanisterOpenMessageContentIdl,\n  'AckMessage': CanisterAckMessageContentIdl,\n  'KeepAliveMessage': ClientKeepAliveMessageContentIdl,\n  'CloseMessage': CanisterCloseMessageContentIdl,\n});\n\nexport const decodeWebsocketServiceMessageContent = (bytes: Uint8Array): WebsocketServiceMessageContent => {\n  const decoded = IDL.decode([WebsocketServiceMessageContentIdl], bytes);\n  if (decoded.length !== 1) {\n    throw new Error(\"Invalid CanisterServiceMessage\");\n  }\n  return decoded[0] as unknown as WebsocketServiceMessageContent;\n};\n\nexport const encodeWebsocketServiceMessageContent = (msg: WebsocketServiceMessageContent): Uint8Array => {\n  return new Uint8Array(IDL.encode([WebsocketServiceMessageContentIdl], [msg]));\n};\n\nexport const isClientKeyEq = (a: ClientKey, b: ClientKey): boolean => {\n  return a.client_principal.compareTo(b.client_principal) === \"eq\" && a.client_nonce === b.client_nonce;\n};\n\n/**\n * Extracts the message type from the canister service definition.\n * \n * @throws {Error} if the canister does not implement the ws_message method\n * @throws {Error} if the application message type is not optional\n */\nexport const extractApplicationMessageIdlFromActor = <T, S extends _WS_CANISTER_SERVICE<T>>(actor: ActorSubclass<S>): IDL.Type<T> => {\n  const wsMessageMethod = Actor.interfaceOf(actor)._fields.find((f) => f[0] === \"ws_message\");\n\n  if (!wsMessageMethod) {\n    throw new Error(\"Canister does not implement ws_message method\");\n  }\n\n  if (wsMessageMethod[1].argTypes.length !== 2) {\n    throw new Error(\"ws_message method must have 2 arguments\");\n  }\n\n  const applicationMessageArg = wsMessageMethod[1].argTypes[1] as IDL.OptClass<T>;\n  if (!(applicationMessageArg instanceof IDL.OptClass)) {\n    throw new Error(\"Application message type must be optional in the ws_message arguments\");\n  }\n\n  return applicationMessageArg[\"_type\"]; // extract the underlying option type\n};\n"]}