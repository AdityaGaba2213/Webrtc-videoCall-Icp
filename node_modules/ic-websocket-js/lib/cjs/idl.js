"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractApplicationMessageIdlFromActor = exports.isClientKeyEq = exports.encodeWebsocketServiceMessageContent = exports.decodeWebsocketServiceMessageContent = exports.wsMessageIdl = exports.wsOpenIdl = exports.CanisterWsMessageResultIdl = exports.CanisterWsMessageArgumentsIdl = void 0;
const candid_1 = require("@dfinity/candid");
const agent_1 = require("@dfinity/agent");
;
const ClientPrincipalIdl = candid_1.IDL.Principal;
const GatewayPrincipalIdl = candid_1.IDL.Principal;
const ClientKeyIdl = candid_1.IDL.Record({
    'client_principal': ClientPrincipalIdl,
    'client_nonce': candid_1.IDL.Nat64,
});
const WebsocketMessageIdl = candid_1.IDL.Record({
    'sequence_num': candid_1.IDL.Nat64,
    'content': candid_1.IDL.Vec(candid_1.IDL.Nat8),
    'client_key': ClientKeyIdl,
    'timestamp': candid_1.IDL.Nat64,
    'is_service_message': candid_1.IDL.Bool,
});
exports.CanisterWsMessageArgumentsIdl = candid_1.IDL.Record({ 'msg': WebsocketMessageIdl });
exports.CanisterWsMessageResultIdl = candid_1.IDL.Variant({
    'Ok': candid_1.IDL.Null,
    'Err': candid_1.IDL.Text,
});
const CanisterWsOpenArgumentsIdl = candid_1.IDL.Record({
    'client_nonce': candid_1.IDL.Nat64,
    'gateway_principal': GatewayPrincipalIdl,
});
const CanisterWsOpenResultIdl = candid_1.IDL.Variant({
    'Ok': candid_1.IDL.Null,
    'Err': candid_1.IDL.Text,
});
exports.wsOpenIdl = candid_1.IDL.Func([CanisterWsOpenArgumentsIdl], [CanisterWsOpenResultIdl], []);
exports.wsMessageIdl = candid_1.IDL.Func([exports.CanisterWsMessageArgumentsIdl, candid_1.IDL.Opt(candid_1.IDL.Null)], [exports.CanisterWsMessageResultIdl], []);
const CanisterOpenMessageContentIdl = candid_1.IDL.Record({
    'client_key': ClientKeyIdl,
});
const CanisterAckMessageContentIdl = candid_1.IDL.Record({
    'last_incoming_sequence_num': candid_1.IDL.Nat64,
});
const ClientKeepAliveMessageContentIdl = candid_1.IDL.Record({
    'last_incoming_sequence_num': candid_1.IDL.Nat64,
});
const CloseMessageReasonIdl = candid_1.IDL.Variant({
    'WrongSequenceNumber': candid_1.IDL.Null,
    'InvalidServiceMessage': candid_1.IDL.Null,
    'KeepAliveTimeout': candid_1.IDL.Null,
    'ClosedByApplication': candid_1.IDL.Null,
});
const CanisterCloseMessageContentIdl = candid_1.IDL.Record({
    'reason': CloseMessageReasonIdl,
});
const WebsocketServiceMessageContentIdl = candid_1.IDL.Variant({
    'OpenMessage': CanisterOpenMessageContentIdl,
    'AckMessage': CanisterAckMessageContentIdl,
    'KeepAliveMessage': ClientKeepAliveMessageContentIdl,
    'CloseMessage': CanisterCloseMessageContentIdl,
});
const decodeWebsocketServiceMessageContent = (bytes) => {
    const decoded = candid_1.IDL.decode([WebsocketServiceMessageContentIdl], bytes);
    if (decoded.length !== 1) {
        throw new Error("Invalid CanisterServiceMessage");
    }
    return decoded[0];
};
exports.decodeWebsocketServiceMessageContent = decodeWebsocketServiceMessageContent;
const encodeWebsocketServiceMessageContent = (msg) => {
    return new Uint8Array(candid_1.IDL.encode([WebsocketServiceMessageContentIdl], [msg]));
};
exports.encodeWebsocketServiceMessageContent = encodeWebsocketServiceMessageContent;
const isClientKeyEq = (a, b) => {
    return a.client_principal.compareTo(b.client_principal) === "eq" && a.client_nonce === b.client_nonce;
};
exports.isClientKeyEq = isClientKeyEq;
/**
 * Extracts the message type from the canister service definition.
 *
 * @throws {Error} if the canister does not implement the ws_message method
 * @throws {Error} if the application message type is not optional
 */
const extractApplicationMessageIdlFromActor = (actor) => {
    const wsMessageMethod = agent_1.Actor.interfaceOf(actor)._fields.find((f) => f[0] === "ws_message");
    if (!wsMessageMethod) {
        throw new Error("Canister does not implement ws_message method");
    }
    if (wsMessageMethod[1].argTypes.length !== 2) {
        throw new Error("ws_message method must have 2 arguments");
    }
    const applicationMessageArg = wsMessageMethod[1].argTypes[1];
    if (!(applicationMessageArg instanceof candid_1.IDL.OptClass)) {
        throw new Error("Application message type must be optional in the ws_message arguments");
    }
    return applicationMessageArg["_type"]; // extract the underlying option type
};
exports.extractApplicationMessageIdlFromActor = extractApplicationMessageIdlFromActor;
//# sourceMappingURL=idl.js.map