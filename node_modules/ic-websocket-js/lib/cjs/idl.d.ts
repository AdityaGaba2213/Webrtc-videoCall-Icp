import { IDL } from "@dfinity/candid";
import type { Principal } from '@dfinity/principal';
import { ActorSubclass, type ActorMethod } from '@dfinity/agent';
import type { GetInnerType } from "./types";
type ClientPrincipal = Principal;
type GatewayPrincipal = Principal;
export type ClientKey = {
    'client_principal': ClientPrincipal;
    'client_nonce': bigint;
};
export interface WebsocketMessage {
    'sequence_num': bigint;
    'content': Uint8Array | number[];
    'client_key': ClientKey;
    'timestamp': bigint;
    'is_service_message': boolean;
}
export interface CanisterWsMessageArguments {
    'msg': WebsocketMessage;
}
export type CanisterWsMessageResult = {
    'Ok': null;
} | {
    'Err': string;
};
export type CanisterWsOpenArguments = {
    'client_nonce': bigint;
    'gateway_principal': GatewayPrincipal;
};
export type CanisterWsOpenResult = {
    'Ok': null;
} | {
    'Err': string;
};
export interface _WS_CANISTER_SERVICE<T = any> {
    'ws_message': ActorMethod<[
        CanisterWsMessageArguments,
        [] | [T]
    ], CanisterWsMessageResult>;
    'ws_open': ActorMethod<[CanisterWsOpenArguments], CanisterWsOpenResult>;
}
/**
 * Extracts the application message type from the canister service definition.
 */
export type GetApplicationMessageType<Service extends _WS_CANISTER_SERVICE> = Exclude<GetInnerType<Service["ws_message"]>[1], []>[0];
export declare const CanisterWsMessageArgumentsIdl: IDL.RecordClass;
export declare const CanisterWsMessageResultIdl: IDL.VariantClass;
export declare const wsOpenIdl: IDL.FuncClass;
export declare const wsMessageIdl: IDL.FuncClass;
type CanisterOpenMessageContent = {
    'client_key': ClientKey;
};
export type CanisterAckMessageContent = {
    'last_incoming_sequence_num': bigint;
};
export type ClientKeepAliveMessageContent = {
    'last_incoming_sequence_num': bigint;
};
export type CloseMessageReason = {
    WrongSequenceNumber: null;
} | {
    InvalidServiceMessage: null;
} | {
    KeepAliveTimeout: null;
} | {
    ClosedByApplication: null;
};
export type CanisterCloseMessageContent = {
    reason: CloseMessageReason;
};
export type WebsocketServiceMessageContent = {
    OpenMessage: CanisterOpenMessageContent;
} | {
    AckMessage: CanisterAckMessageContent;
} | {
    KeepAliveMessage: ClientKeepAliveMessageContent;
} | {
    CloseMessage: CanisterCloseMessageContent;
};
export declare const decodeWebsocketServiceMessageContent: (bytes: Uint8Array) => WebsocketServiceMessageContent;
export declare const encodeWebsocketServiceMessageContent: (msg: WebsocketServiceMessageContent) => Uint8Array;
export declare const isClientKeyEq: (a: ClientKey, b: ClientKey) => boolean;
/**
 * Extracts the message type from the canister service definition.
 *
 * @throws {Error} if the canister does not implement the ws_message method
 * @throws {Error} if the application message type is not optional
 */
export declare const extractApplicationMessageIdlFromActor: <T, S extends _WS_CANISTER_SERVICE<T>>(actor: ActorSubclass<S>) => IDL.Type<T>;
export {};
