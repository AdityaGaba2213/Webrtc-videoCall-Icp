{"version":3,"file":"ic-websocket.js","sourceRoot":"","sources":["../../src/ic-websocket.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  ActorSubclass,\n  Cbor,\n  HttpAgent,\n  SignIdentity,\n} from \"@dfinity/agent\";\nimport { IDL } from \"@dfinity/candid\";\nimport { Principal } from \"@dfinity/principal\";\nimport {\n  CanisterAckMessageContent,\n  CanisterCloseMessageContent,\n  CanisterWsMessageArguments,\n  ClientKeepAliveMessageContent,\n  ClientKey,\n  GetApplicationMessageType,\n  WebsocketMessage,\n  _WS_CANISTER_SERVICE,\n  decodeWebsocketServiceMessageContent,\n  encodeWebsocketServiceMessageContent,\n  extractApplicationMessageIdlFromActor,\n  isClientKeyEq,\n} from \"./idl\";\nimport { logger } from \"./logger\";\nimport { isMessageBodyValid, randomBigInt, safeExecute } from \"./utils\";\nimport {\n  isClientIncomingMessage,\n  type ClientIncomingMessage,\n  isGatewayHandshakeMessage,\n  type GatewayHandshakeMessage,\n} from \"./types\";\nimport { callCanisterWsMessage, callCanisterWsOpen } from \"./actor\";\nimport {\n  AckMessagesQueue,\n  BaseQueue,\n} from \"./queues\";\nimport { WsAgent } from \"./agent\";\n\n/**\n * The default interval (in milliseconds) at which the canister sends an ack message.\n */\nconst DEFAULT_ACK_MESSAGE_INTERVAL_MS = 300_000;\n/**\n * The maximum communication latency allowed between the client and the canister (same as in the canister).\n * \n * Used to determine the ack message timeout.\n */\nexport const COMMUNICATION_LATENCY_BOUND_MS = 30_000;\n\n/**\n * Interface to create a new IcWebSocketConfig. For a simple configuration, use {@link createWsConfig}.\n */\nexport interface IcWebSocketConfig<S extends _WS_CANISTER_SERVICE> {\n  /**\n   * The canister id of the canister to open the WebSocket to.\n   */\n  canisterId: string | Principal;\n  /**\n   * The canister actor used to serialize and deserialize the application messages.\n   */\n  canisterActor: ActorSubclass<S>;\n  /**\n   * The identity to use for signing messages.\n   * If you don't want to use an identity (e.g. your users are anonymous), you can use the `generateRandomIdentity`\n   * helper function exported by this package to generate a new temporary identity.\n   */\n  identity: SignIdentity,\n  /**\n   * The IC network url to use for the underlying agent. It can be a local replica URL (e.g. http://localhost:4943) or the IC mainnet URL (https://icp-api.io).\n   */\n  networkUrl: string;\n  /**\n   * The interval (in milliseconds) at which the canister sends an ack message.\n   * This parameter must be **equal** to the canister's send ack interval.\n   * \n   * @default 300_000 (default send ack period on the canister)\n   */\n  ackMessageIntervalMs?: number;\n  /**\n   * The maximum age of the certificate received from the canister, in minutes. You won't likely need to set this parameter. Used in tests.\n   * \n   * @default 5 (5 minutes)\n   */\n  maxCertificateAgeInMinutes?: number;\n};\n\n/**\n * Creates a new {@link IcWebSocketConfig} from arguments.\n */\nexport const createWsConfig = <S extends _WS_CANISTER_SERVICE>(c: IcWebSocketConfig<S>): IcWebSocketConfig<S> => c;\n\ntype WsParameters = ConstructorParameters<typeof WebSocket>;\n\nexport class IcWebSocket<\n  S extends _WS_CANISTER_SERVICE,\n  ApplicationMessageType = GetApplicationMessageType<S>\n> {\n  public readonly canisterId: Principal;\n  private readonly _canisterActor: ActorSubclass<S>;\n  private readonly _applicationMessageIdl: IDL.Type<ApplicationMessageType>;\n  private readonly _httpAgent: HttpAgent;\n  private _wsAgent: WsAgent | null = null;\n  private readonly _wsInstance: WebSocket;\n  private readonly _identity: SignIdentity;\n  private _incomingSequenceNum = BigInt(1);\n  private _outgoingSequenceNum = BigInt(0);\n  private _isHandshakeCompleted = false;\n  private _isConnectionEstablished = false;\n  private _incomingMessagesQueue: BaseQueue<ArrayBuffer>;\n  private _outgoingMessagesQueue: BaseQueue<Uint8Array>;\n  private _ackMessagesQueue: AckMessagesQueue;\n  private _clientKey: ClientKey;\n  private _gatewayPrincipal: Principal | null = null;\n  private _maxCertificateAgeInMinutes = 5;\n  private _openTimeout: NodeJS.Timeout | null = null;\n\n  onclose: ((this: IcWebSocket<S, ApplicationMessageType>, ev: CloseEvent) => any) | null = null;\n  onerror: ((this: IcWebSocket<S, ApplicationMessageType>, ev: ErrorEvent) => any) | null = null;\n  onmessage: ((this: IcWebSocket<S, ApplicationMessageType>, ev: MessageEvent<ApplicationMessageType>) => any) | null = null;\n  onopen: ((this: IcWebSocket<S, ApplicationMessageType>, ev: Event) => any) | null = null;\n\n  /**\n   * Returns the state of the WebSocket object's connection.\n   */\n  get readyState(): number {\n    return this._wsInstance.readyState;\n  }\n\n  // forwards the WebSocket state constants\n  public readonly CLOSED = WebSocket.CLOSED;\n  public readonly CLOSING = WebSocket.CLOSING;\n  public readonly CONNECTING = WebSocket.CONNECTING;\n  public readonly OPEN = WebSocket.OPEN;\n\n  /**\n   * Creates a new IcWebSocket instance, waiting **30 seconds** for the WebSocket to be open.\n   * @param url The gateway address.\n   * @param protocols The protocols to use in the WebSocket.\n   * @param config The IcWebSocket configuration. Use {@link createWsConfig} to create a new configuration.\n   */\n  constructor(url: WsParameters[0], protocols: WsParameters[1], config: IcWebSocketConfig<S>) {\n    this.canisterId = Principal.from(config.canisterId);\n\n    if (!config.canisterActor) {\n      throw new Error(\"Canister actor is required\");\n    }\n    this._canisterActor = config.canisterActor;\n    this._applicationMessageIdl = extractApplicationMessageIdlFromActor(this._canisterActor);\n\n    if (!config.identity) {\n      throw new Error(\"Identity is required\");\n    }\n    if (!(config.identity instanceof SignIdentity)) {\n      throw new Error(\"Identity must be a SignIdentity\");\n    }\n    this._identity = config.identity;\n\n    this._clientKey = {\n      client_principal: this.getPrincipal(),\n      client_nonce: randomBigInt(),\n    };\n\n    if (!config.networkUrl) {\n      throw new Error(\"Network url is required\");\n    }\n\n    this._httpAgent = HttpAgent.createSync({\n      host: config.networkUrl,\n      identity: this._identity,\n    });\n    // follow the same logic of the HttpAgent to decide whether to fetch the root key or not\n    // see https://github.com/dfinity/agent-js/blob/ed4f2d0a204bb2737d2bc490dcbcabb8a87a8051/packages/agent/src/agent/http/index.ts#L336C9-L336C55\n    if (this._httpAgent.host.toString() !== 'https://icp-api.io') {\n      void this._httpAgent.fetchRootKey();\n    }\n\n    this._incomingMessagesQueue = new BaseQueue({\n      itemCallback: this._processIncomingMessage.bind(this),\n      isDisabled: true,\n    });\n\n    this._outgoingMessagesQueue = new BaseQueue({\n      itemCallback: this._sendMessageFromQueue.bind(this),\n      isDisabled: true,\n    });\n\n    this._ackMessagesQueue = new AckMessagesQueue({\n      expirationMs: (config.ackMessageIntervalMs || DEFAULT_ACK_MESSAGE_INTERVAL_MS) + COMMUNICATION_LATENCY_BOUND_MS,\n      timeoutExpiredCallback: this._onAckMessageTimeout.bind(this),\n    });\n\n    if (config.maxCertificateAgeInMinutes) {\n      this._maxCertificateAgeInMinutes = config.maxCertificateAgeInMinutes;\n    }\n\n    this._wsInstance = new WebSocket(url, protocols); // Gateway address. Here localhost to reproduce the demo.\n    this._wsInstance.binaryType = \"arraybuffer\";\n    this._bindWsEvents();\n  }\n\n  public send(message: ApplicationMessageType) {\n    if (!this._isConnectionEstablished) {\n      throw new Error(\"Connection is not established yet\");\n    }\n\n    const data = IDL.encode([this._applicationMessageIdl], [message]);\n\n    this._outgoingMessagesQueue.addAndProcess(new Uint8Array(data));\n  }\n\n  public getPrincipal(): Principal {\n    return this._identity.getPrincipal();\n  }\n\n  public close() {\n    this._wsInstance.close(1000);\n  }\n\n  public isConnectionEstablished(): boolean {\n    return this._isConnectionEstablished;\n  }\n\n  private _bindWsEvents() {\n    this._wsInstance.onopen = this._onWsOpen.bind(this);\n    this._wsInstance.onmessage = this._onWsMessage.bind(this);\n    this._wsInstance.onclose = this._onWsClose.bind(this);\n    this._wsInstance.onerror = this._onWsError.bind(this);\n  }\n\n  private async _onWsOpen() {\n    this._incomingMessagesQueue.enableAndProcess();\n\n    logger.debug(\"[onWsOpen] WebSocket opened\");\n  }\n\n  private _onWsMessage(event: MessageEvent<ArrayBuffer>) {\n    this._incomingMessagesQueue.addAndProcess(event.data);\n  }\n\n  private _startOpenTimeout() {\n    // the timeout is double the maximum allowed network latency,\n    // because opening the connection involves a message sent by the client and one by the canister\n    this._openTimeout = setTimeout(() => {\n      if (!this._isConnectionEstablished) {\n        logger.error(\"[onWsOpen] Error: Open timeout expired before receiving the open message\");\n        this._callOnErrorCallback(new Error(\"Open timeout expired before receiving the open message\"));\n        this._wsInstance.close(4000, \"Open connection timeout\");\n      }\n\n      this._openTimeout = null;\n    }, 2 * COMMUNICATION_LATENCY_BOUND_MS);\n  }\n\n  private _cancelOpenTimeout() {\n    if (this._openTimeout) {\n      clearTimeout(this._openTimeout);\n      this._openTimeout = null;\n    }\n  }\n\n  private async _handleHandshakeMessage(handshakeMessage: GatewayHandshakeMessage): Promise<boolean> {\n    // at this point, we're sure that the gateway_principal is valid\n    // because the isGatewayHandshakeMessage function checks it\n    this._gatewayPrincipal = Principal.from(handshakeMessage.gateway_principal);\n    this._isHandshakeCompleted = true;\n\n    try {\n      await this._sendOpenMessage();\n\n      this._startOpenTimeout();\n    } catch (error) {\n      logger.error(\"[onWsMessage] Handshake message error:\", error);\n      // if a handshake message fails, we can't continue\n      this._wsInstance.close(4000, \"Handshake message error\");\n      return false;\n    }\n\n    return true;\n  }\n\n  private _initializeWsAgent() {\n    this._wsAgent = new WsAgent({\n      identity: this._identity,\n      httpAgent: this._httpAgent,\n      ws: this._wsInstance,\n    });\n  }\n\n  private async _sendOpenMessage() {\n    this._initializeWsAgent();\n\n    logger.debug(\"Sending open message\");\n\n    // Call the canister's ws_open method\n    // at this point, all the class properties that we need are initialized\n    await callCanisterWsOpen(\n      this.canisterId,\n      this._wsAgent!,\n      {\n        client_nonce: this._clientKey.client_nonce,\n        gateway_principal: this._gatewayPrincipal!,\n      }\n    );\n\n    logger.debug(\"Open message sent, waiting for first open message from canister\");\n  }\n\n  private async _processIncomingMessage(message: ArrayBuffer): Promise<boolean> {\n    try {\n      const incomingMessage = this._decodeIncomingMessage(message);\n\n      // if the handshake is not completed yet, we have to treat the first message as HandshakeMessage\n      if (!this._isHandshakeCompleted) {\n        if (!isGatewayHandshakeMessage(incomingMessage)) {\n          throw new Error(\"First message is not a GatewayHandshakeMessage\");\n        }\n\n        return this._handleHandshakeMessage(incomingMessage);\n      }\n\n      // Check if the incoming message is a ClientIncomingMessage\n      if (!isClientIncomingMessage(incomingMessage)) {\n        throw new Error(\"Incoming message is not a ClientIncomingMessage\");\n      }\n\n      logger.debug(\"[onWsMessage] Incoming message received. Bytes:\", message.byteLength, \"bytes\");\n\n      const websocketMessage = this._decodeIncomingMessageContent(incomingMessage);\n\n      const isValidMessage = await this._isIncomingMessageValid(incomingMessage);\n      if (!isValidMessage) {\n        throw new Error(\"[onWsMessage] Certificate validation failed\");\n      }\n\n      const isSequenceNumValid = this._isWebsocketMessageSequenceNumberValid(websocketMessage);\n      if (!isSequenceNumValid) {\n        throw new Error(`[onWsMessage] Received message sequence number does not match next expected value. Expected: ${this._incomingSequenceNum}, received: ${websocketMessage.sequence_num}`);\n      }\n      // Increment the next expected sequence number\n      this._incomingSequenceNum++;\n\n      // handle the case in which the content is a service message\n      if (websocketMessage.is_service_message) {\n        logger.debug(\"[onWsMessage] Received service message from canister\");\n        return this._handleServiceMessage(websocketMessage.content as Uint8Array);\n      }\n\n      this._inspectWebsocketMessageTimestamp(websocketMessage);\n\n      await this._callOnMessageCallback(new Uint8Array(websocketMessage.content));\n    } catch (error) {\n      // for any error, we can't continue\n      logger.error(\"[onWsMessage]\", error);\n      this._callOnErrorCallback(new Error(`Error receiving message: ${error}`));\n      this._wsInstance.close(4000, \"Error receiving message\");\n      return false;\n    }\n\n    return true;\n  }\n\n  private async _handleServiceMessage(content: Uint8Array): Promise<boolean> {\n    try {\n      const serviceMessage = decodeWebsocketServiceMessageContent(content as Uint8Array);\n      if (\"OpenMessage\" in serviceMessage) {\n        logger.debug(\"[onWsMessage] Received open message from canister\");\n        if (!isClientKeyEq(serviceMessage.OpenMessage.client_key, this._clientKey)) {\n          throw new Error(\"Client key does not match\");\n        }\n\n        this._isConnectionEstablished = true;\n        this._cancelOpenTimeout();\n\n        this._callOnOpenCallback();\n\n        this._outgoingMessagesQueue.enableAndProcess();\n      } else if (\"AckMessage\" in serviceMessage) {\n        await this._handleAckMessageFromCanister(serviceMessage.AckMessage);\n      } else if (\"CloseMessage\" in serviceMessage) {\n        await this._handleCloseMessageFromCanister(serviceMessage.CloseMessage);\n        // we don't have to process any further message (there shouldn't be any anyway)\n        return false;\n      } else {\n        throw new Error(\"Invalid service message from canister\");\n      }\n    } catch (error) {\n      logger.error(\"[onWsMessage] Service message error:\", error);\n      // if a service message fails, we can't continue\n      this._wsInstance.close(4000, \"Service message error\");\n      return false;\n    }\n\n    return true;\n  }\n\n  private async _handleAckMessageFromCanister(content: CanisterAckMessageContent): Promise<void> {\n    const lastAckSequenceNumberFromCanister = BigInt(content.last_incoming_sequence_num);\n    logger.debug(\"[onWsMessage] Received ack message from canister with sequence number\", lastAckSequenceNumberFromCanister);\n\n    try {\n      this._ackMessagesQueue.ack(lastAckSequenceNumberFromCanister);\n    } catch (error) {\n      logger.error(\"[onWsMessage] Ack message error:\", error);\n      this._callOnErrorCallback(new Error(`Ack message error: ${error}`));\n      return this._wsInstance.close(4000, \"Ack message error\");\n    }\n\n    await this._sendKeepAliveMessage();\n  }\n\n  private async _handleCloseMessageFromCanister(content: CanisterCloseMessageContent): Promise<void> {\n    if (\"ClosedByApplication\" in content.reason) {\n      logger.debug(\"[onWsMessage] Received close message from canister. Reason: ClosedByApplication\");\n      this._wsInstance.close(4001, \"ClosedByApplication\");\n    } else {\n      logger.error(\"[onWsMessage] Received close message from canister. Reason:\", content.reason);\n      this._callOnErrorCallback(new Error(`Received close message from canister. Reason: ${content.reason}`));\n      this._wsInstance.close(4000, \"Received close message from canister\");\n    }\n  }\n\n  private async _sendKeepAliveMessage(): Promise<void> {\n    const keepAliveMessageContent: ClientKeepAliveMessageContent = {\n      last_incoming_sequence_num: this._incomingSequenceNum - BigInt(1),\n    };\n    const bytes = encodeWebsocketServiceMessageContent({\n      KeepAliveMessage: keepAliveMessageContent,\n    });\n    const keepAliveMessage = this._makeWsMessageArguments(new Uint8Array(bytes), true);\n\n    const sent = await this._sendMessageToCanister(keepAliveMessage);\n    if (!sent) {\n      logger.error(\"[onWsMessage] Keep alive message was not sent\");\n      this._callOnErrorCallback(new Error(\"Keep alive message was not sent\"));\n      this._wsInstance.close(4000, \"Keep alive message was not sent\");\n    }\n  }\n\n  private _onAckMessageTimeout(notReceivedAcks: bigint[]) {\n    logger.error(\"[onAckMessageTimeout] Ack message timeout. Not received ack for sequence numbers:\", notReceivedAcks);\n    this._callOnErrorCallback(new Error(`Ack message timeout. Not received ack for sequence numbers: ${notReceivedAcks}`));\n    this._wsInstance.close(4000, \"Ack message timeout\");\n  }\n\n  private _onWsClose(event: CloseEvent) {\n    logger.debug(`[onWsClose] WebSocket closed, code=${event.code} reason=${event.reason}`);\n\n    this._isConnectionEstablished = false;\n    this._incomingMessagesQueue.disable();\n    this._outgoingMessagesQueue.disable();\n    this._ackMessagesQueue.clear();\n\n    this._callOnCloseCallback(event);\n  }\n\n  private _onWsError(error: Event) {\n    logger.error(\"[onWsError]\", error);\n    this._callOnErrorCallback(new Error(`WebSocket error: ${error}`));\n  }\n\n  private _sendMessageFromQueue(messageContent: Uint8Array): Promise<boolean> {\n    const message = this._makeWsMessageArguments(messageContent!);\n    // we send the message via WebSocket to the gateway, which relays it to the canister\n    return this._sendMessageToCanister(message);\n  }\n\n  /**\n   * Sends a message to the canister via WebSocket, using a method that uses the {@link WsAgent}.\n   * @param message \n   * @returns {boolean} `true` if the message was sent successfully, `false` otherwise.\n   */\n  private async _sendMessageToCanister(message: CanisterWsMessageArguments): Promise<boolean> {\n    // we don't need to wait for the response,\n    // as we'll receive the ack message via WebSocket from the canister\n    try {\n      await callCanisterWsMessage(\n        this.canisterId,\n        this._wsAgent!,\n        message\n      );\n\n      // add the sequence number to the ack messages queue\n      this._ackMessagesQueue.add(message.msg.sequence_num);\n\n      logger.debug(\"[send] Message sent\");\n    } catch (error) {\n      // the ws agent already tries 3 times under the hood, so if we get an error here, we can't continue\n      logger.error(\"[send] Message sending failed:\", error);\n      this._callOnErrorCallback(new Error(`Message sending failed: ${error}`));\n      this._wsInstance.close(4000, \"Message sending failed\");\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * CBOR decodes the incoming message from an ArrayBuffer and returns an object.\n   *\n   * @param {ArrayBuffer} buf - The ArrayBuffer containing the encoded message.\n   * @returns {any} The decoded object.\n   */\n  private _decodeIncomingMessage(buf: ArrayBuffer): any {\n    return Cbor.decode(buf);\n  }\n\n  private async _isIncomingMessageValid(incomingMessage: ClientIncomingMessage): Promise<boolean> {\n    const key = incomingMessage.key;\n    const content = new Uint8Array(incomingMessage.content); // make sure it's a Uint8Array\n    const cert = incomingMessage.cert;\n    const tree = incomingMessage.tree;\n\n    // Verify the certificate (canister signature)\n    const isValid = await isMessageBodyValid(\n      this.canisterId,\n      key,\n      content,\n      cert,\n      tree,\n      this._httpAgent,\n      this._maxCertificateAgeInMinutes,\n    );\n\n    return isValid;\n  }\n\n  private _decodeIncomingMessageContent(incomingMessage: ClientIncomingMessage): WebsocketMessage {\n    const websocketMessage = Cbor.decode<WebsocketMessage>(incomingMessage.content);\n\n    return websocketMessage;\n  }\n\n  private _isWebsocketMessageSequenceNumberValid(incomingContent: WebsocketMessage): boolean {\n    const receivedNum = incomingContent.sequence_num;\n    logger.debug(\"[onWsMessage] Received message with sequence number\", receivedNum)\n    return BigInt(receivedNum) === this._incomingSequenceNum;\n  }\n\n  private _inspectWebsocketMessageTimestamp(incomingContent: WebsocketMessage) {\n    const time = BigInt(incomingContent.timestamp) / BigInt(10 ** 6);\n    const delayMilliseconds = BigInt(Date.now()) - time;\n    logger.debug(\"[onWsMessage] Canister --> client latency(ms):\", Number(delayMilliseconds));\n  }\n\n  private _makeWsMessageArguments(content: Uint8Array, isServiceMessage = false): CanisterWsMessageArguments {\n    this._outgoingSequenceNum++;\n\n    const outgoingMessage: WebsocketMessage = {\n      client_key: this._clientKey,\n      sequence_num: this._outgoingSequenceNum,\n      timestamp: BigInt(Date.now()) * BigInt(10 ** 6),\n      content,\n      is_service_message: isServiceMessage,\n    };\n\n    return {\n      msg: outgoingMessage,\n    };\n  }\n\n  private _callOnOpenCallback() {\n    safeExecute(() => {\n      if (this.onopen) {\n        logger.debug(\"[onopen] Calling onopen callback\");\n        this.onopen.call(this, new Event(\"open\"))\n      } else {\n        logger.warn(\"[onopen] No onopen callback defined\");\n      }\n    }, \"Calling onopen callback failed\");\n  }\n\n  private async _callOnMessageCallback(data: Uint8Array): Promise<void> {\n    if (this.onmessage) {\n      logger.debug(\"[onmessage] Calling onmessage callback\");\n      const decoded = IDL.decode([this._applicationMessageIdl], data)[0] as ApplicationMessageType;\n\n      await safeExecute(() => {\n        this.onmessage!.call(this, new MessageEvent(\"message\", { data: decoded }))\n      }, \"Calling onmessage callback failed\");\n\n    } else {\n      logger.warn(\"[onmessage] No onmessage callback defined\");\n    }\n  }\n\n  private _callOnErrorCallback(error: Error) {\n    safeExecute(() => {\n      if (this.onerror) {\n        logger.debug(\"[onerror] Calling onerror callback\");\n        this.onerror.call(this, new ErrorEvent(\"error\", { error }));\n      } else {\n        logger.warn(\"[onerror] No onerror callback defined\");\n      }\n    }, \"Calling onerror callback failed\");\n  }\n\n  private _callOnCloseCallback(event: CloseEvent) {\n    safeExecute(() => {\n      if (this.onclose) {\n        logger.debug(\"[onclose] Calling onclose callback\");\n        this.onclose.call(this, event);\n      } else {\n        logger.warn(\"[onclose] No onclose callback defined\");\n      }\n    }, \"Calling onclose callback failed\");\n  }\n}\n"]}